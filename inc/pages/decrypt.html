<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>D-Crypt | Decrypt</title>
  <link rel="stylesheet" href="../style.css" />

  <!-- Required libraries -->
  <script src="../../libsodium.js-master/dist/browsers/sodium.js" defer></script>
  <script src="../keys.js" defer></script>
  <script src="../contacts.js" defer></script>
  <script src="../script.js" defer></script>
</head>

<body>
  <!-- HEADER -->
  <header>
    <div class="container">
      <div class="logo">D-Crypt <span class="version">v1.2</span></div>
      <button id="menu-toggle" aria-label="Open menu">☰</button>
      <nav>
        <ul id="menu">
          <li><a href="../../index.html">Encrypt</a></li>
          <li><a href="decrypt.html" class="active">Decrypt</a></li>
          <li><a href="about.html">About</a></li>
          <li><a href="gen-keys.html">Keys generation</a></li>
          <li><a href="addContact.html">Manage contacts</a></li>
          <li><a href="duplication.html">Duplicate D-Crypt</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- MAIN CONTENT -->
  <main class="content">
    <!-- DECRYPT MESSAGE SECTION -->
    <section id="decryptMessageSection">
      <h1>Decrypt a Message or File</h1>

      <form id="messageForm" novalidate>
        <!-- Choose decryption key -->
        <div class="form-group">
          <label for="keyType">Decrypt using:</label>
          <select id="keyType" required>
            <option value="global">Global Key</option>
            <option value="self">Myself Key</option>
          </select>
        </div>

        <!-- Paste encrypted text -->
        <div class="form-group">
          <label for="messageInput">Encrypted Data</label>
          <textarea id="messageInput" rows="5" placeholder="Paste encrypted content here or upload a D-Crypt TXT file..." required></textarea>
        </div>

        <!-- Load from exported TXT -->
        <div class="form-group">
          <label>Or upload a D-Crypt TXT file:</label>
          <input type="file" id="txtFileInput" accept=".txt">
        </div>

        <button id="decryptButton" type="submit">Decrypt</button>
      </form>
    </section>

    <!-- DECRYPTED RESULT -->
    <section id="decryptedContent" class="hidden">
      <h2>Decryption Result</h2>
      <div id="decryptedMessage" class="decrypted-message"></div>
      <div id="downloadLink" class="download-section"></div>
    </section>
  </main>

  <!-- FOOTER -->
  <footer>
    <p>&copy; <span id="current-year"></span> D-Crypt. All rights reserved.</p>
  </footer>

  <!-- MAIN SCRIPT -->
  <script>
  document.addEventListener('DOMContentLoaded', async () => {
    // === Element references ===
    const form = document.getElementById('messageForm');
    const decryptButton = document.getElementById('decryptButton');
    const messageInput = document.getElementById('messageInput');
    const keyTypeSelect = document.getElementById('keyType');
    const decryptedContent = document.getElementById('decryptedContent');
    const decryptedMessage = document.getElementById('decryptedMessage');
    const downloadLinkDiv = document.getElementById('downloadLink');
    const txtFileInput = document.getElementById('txtFileInput');

    // Update year dynamically in footer
    document.getElementById('current-year').textContent = new Date().getFullYear();

    // Wait for libsodium to be ready
    await waitForSodium().catch(err => {
      alert('Failed to load the encryption library.');
      console.error(err);
    });

    // ==========================
    // Read a D-Crypt TXT file
    // ==========================
    txtFileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const cleaned = cleanTXTContent(text);
        messageInput.value = cleaned;
        messageInput.scrollIntoView({ behavior: 'smooth' });
      } catch (err) {
        alert('Failed to read the TXT file.');
        console.error(err);
      }
    });

    // ==========================
    // Main decryption process
    // ==========================
    form.addEventListener('submit', async (e) => {
      e.preventDefault();

      let encryptedText = messageInput.value.trim();
      if (!encryptedText) {
        alert('Please paste or load an encrypted message first.');
        return;
      }

      decryptButton.disabled = true;
      decryptButton.textContent = 'Decrypting...';

      try {
        const keyType = keyTypeSelect.value;

        // Detect if the content is a file (tagged with [ext]...[/ext])
        const fileMatch = encryptedText.match(/\[(\w+)\]([\s\S]*?)\[\/\1\]/i);

        if (fileMatch) {
          // === File decryption ===
          const fileType = fileMatch[1].toLowerCase();
          const encryptedBase64 = fileMatch[2];
          const encryptedBytes = sodium.from_base64(encryptedBase64, sodium.base64_variants.URLSAFE_NO_PADDING);
          const decryptedBytes = decryptMessage(sodium, encryptedBytes, keyType);
          showDownloadLink(decryptedBytes, fileType);
        } else {
          // === Text decryption ===
          const encryptedBytes = sodium.from_base64(encryptedText, sodium.base64_variants.URLSAFE_NO_PADDING);
          const decryptedText = decryptTextMessage(sodium, encryptedBytes, keyType);
          showDecryptedText(decryptedText);
        }
      } catch (err) {
        console.error('Decryption error:', err);
        alert('Decryption failed: ' + err.message);
      } finally {
        decryptButton.disabled = false;
        decryptButton.textContent = 'Decrypt';
      }
    });

    // ==========================
    // Clean up TXT export content
    // ==========================
    function cleanTXTContent(text) {
      return text
        .replace(/===.*?===/g, '')   // Remove header line
        .replace(/Date:.*?\n/, '')   // Remove date line
        .trim();
    }

    // ==========================
    // Core decryption (binary)
    // ==========================
    function decryptMessage(sodium, encryptedMessage, keyType) {
      const privateKey = sodium.from_base64(keys[keyType].privateKeyBase64);
      const publicKey = sodium.from_base64(keys[keyType].publicKeyBase64);
      const decrypted = sodium.crypto_box_seal_open(encryptedMessage, publicKey, privateKey);
      if (!decrypted) throw new Error('Invalid key or corrupted message.');
      return decrypted;
    }

    // ==========================
    // Core decryption (text)
    // ==========================
    function decryptTextMessage(sodium, encryptedMessage, keyType) {
      const privateKey = sodium.from_base64(keys[keyType].privateKeyBase64);
      const publicKey = sodium.from_base64(keys[keyType].publicKeyBase64);
      const decrypted = sodium.crypto_box_seal_open(encryptedMessage, publicKey, privateKey);
      if (!decrypted) throw new Error('Invalid key or corrupted message.');
      return new TextDecoder().decode(decrypted);
    }

    // ==========================
    // Display decrypted text
    // ==========================
    function showDecryptedText(text) {
      decryptedMessage.textContent = text;
      downloadLinkDiv.innerHTML = '';
      decryptedContent.classList.remove('hidden');
      decryptedContent.scrollIntoView({ behavior: 'smooth' });
    }

    // ==========================
    // Display download link for decrypted files
    // ==========================
    function showDownloadLink(data, fileType) {
      const mimeTypes = {
        png: 'image/png',
        jpg: 'image/jpeg',
        jpeg: 'image/jpeg',
        pdf: 'application/pdf',
        zip: 'application/zip',
        mp3: 'audio/mpeg',
        wav: 'audio/wav',
        ogg: 'audio/ogg',
        mp4: 'video/mp4',
        webm: 'video/webm',
        mov: 'video/quicktime',
        txt: 'text/plain',
      };

      const mimeType = mimeTypes[fileType] || 'application/octet-stream';

      // Convert Uint8Array → Blob safely
      const blob = new Blob([data.buffer], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const filename = `decrypted_${Date.now()}.${fileType}`;

      decryptedMessage.innerHTML = `<p>Decrypted file type: <strong>${fileType.toUpperCase()}</strong></p>`;
      downloadLinkDiv.innerHTML = `
        <a href="${url}" download="${filename}" class="download-link">Download ${fileType.toUpperCase()}</a>
        <audio controls style="display:${mimeType.startsWith('audio/') ? 'block' : 'none'}; margin-top:10px; max-width:100%;">
          <source src="${url}" type="${mimeType}">
          Your browser does not support the audio element.
        </audio>
        <video controls style="display:${mimeType.startsWith('video/') ? 'block' : 'none'}; margin-top:10px; max-width:100%;">
          <source src="${url}" type="${mimeType}">
          Your browser does not support the video element.
        </video>
      `;

      decryptedContent.classList.remove('hidden');
      decryptedContent.scrollIntoView({ behavior: 'smooth' });

      // Revoke after 10 seconds to free memory
      setTimeout(() => URL.revokeObjectURL(url), 10000);
    }

    // ==========================
    // Wait for libsodium to load (with timeout)
    // ==========================
    function waitForSodium(timeout = 5000) {
      return new Promise((resolve, reject) => {
        const start = Date.now();
        const check = setInterval(() => {
          if (window.sodium) {
            clearInterval(check);
            resolve(window.sodium);
          } else if (Date.now() - start > timeout) {
            clearInterval(check);
            reject(new Error('libsodium failed to load.'));
          }
        }, 50);
      });
    }
  });
  </script>

  <!-- INLINE STYLES -->
  <style>
    .form-group { margin-bottom: 1rem; }
    textarea { width: 100%; }
    .hidden { display: none; }

    .download-link {
      display: inline-block;
      margin-top: 10px;
      padding: 8px 16px;
      background: #007bff;
      color: #fff;
      border-radius: 5px;
      text-decoration: none;
    }
    .download-link:hover { background: #0056b3; }
  </style>
</body>
</html>